From 5aaf525f1846ec9070c59c23ff65107e37a5f083 Mon Sep 17 00:00:00 2001
From: Miroslav Ondra <ondra@faster.cz>
Date: Mon, 4 Apr 2022 16:32:49 +0200
Subject: [PATCH 2/6] Add watchdog testing mode into imx2_wdt

---
 drivers/watchdog/imx2_wdt.c | 27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/drivers/watchdog/imx2_wdt.c b/drivers/watchdog/imx2_wdt.c
index d0c5d47dd..f7939deca 100644
--- a/drivers/watchdog/imx2_wdt.c
+++ b/drivers/watchdog/imx2_wdt.c
@@ -35,6 +35,7 @@
 
 #define IMX2_WDT_WCR		0x00		/* Control Register */
 #define IMX2_WDT_WCR_WT		(0xFF << 8)	/* -> Watchdog Timeout Field */
+#define IMX2_WDT_WCR_SRE	BIT(6)		/* -> Software Reset Signal Enable*/
 #define IMX2_WDT_WCR_WDA	BIT(5)		/* -> External Reset WDOG_B */
 #define IMX2_WDT_WCR_SRS	BIT(4)		/* -> Software Reset Signal */
 #define IMX2_WDT_WCR_WRE	BIT(3)		/* -> WDOG Reset Enable */
@@ -67,6 +68,7 @@ struct imx2_wdt_device {
 	bool ext_reset;
 	bool clk_is_on;
 	bool no_ping;
+	bool test_enabled;
 };
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
@@ -100,7 +102,7 @@ static int imx2_wdt_restart(struct watchdog_device *wdog, unsigned long action,
 	if (wdev->ext_reset)
 		wcr_enable |= IMX2_WDT_WCR_SRS; /* do not assert int reset */
 	else
-		wcr_enable |= IMX2_WDT_WCR_WDA; /* do not assert ext-reset */
+		wcr_enable |= IMX2_WDT_WCR_WDA | IMX2_WDT_WCR_SRE; /* do not assert ext-reset */
 
 	/* Assert SRS signal */
 	regmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);
@@ -133,7 +135,7 @@ static inline void imx2_wdt_setup(struct watchdog_device *wdog)
 	val &= ~IMX2_WDT_WCR_WT;
 	/* Generate internal chip-level reset if WDOG times out */
 	if (!wdev->ext_reset)
-		val &= ~IMX2_WDT_WCR_WRE;
+		val = (val & ~IMX2_WDT_WCR_WRE) | IMX2_WDT_WCR_SRE;
 	/* Or if external-reset assert WDOG_B reset only on time-out */
 	else
 		val |= IMX2_WDT_WCR_WRE;
@@ -174,8 +176,23 @@ static void __imx2_wdt_set_timeout(struct watchdog_device *wdog,
 				   unsigned int new_timeout)
 {
 	struct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);
-
-	regmap_update_bits(wdev->regmap, IMX2_WDT_WCR, IMX2_WDT_WCR_WT,
+	unsigned int wcr_enable;
+
+    printk(KERN_INFO "WD: timeout=%d\n", new_timeout);
+
+    if ((wdev->test_enabled) && ((new_timeout==123)||(new_timeout==122))) {
+        regmap_read(wdev->regmap, IMX2_WDT_WCR, &wcr_enable);
+        printk(KERN_INFO "WD: wcr_enable=%x\n", wcr_enable);
+        wcr_enable |= IMX2_WDT_WCR_SRS;  /* do not assert int reset */
+        if (new_timeout==123)
+            wcr_enable &= ~IMX2_WDT_WCR_WDA;
+        else
+            wcr_enable |= IMX2_WDT_WCR_WDA;
+        regmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);
+        regmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);
+        regmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);
+    } else
+	    regmap_update_bits(wdev->regmap, IMX2_WDT_WCR, IMX2_WDT_WCR_WT,
 			   WDOG_SEC_TO_COUNT(new_timeout));
 }
 
@@ -313,6 +330,8 @@ static int __init imx2_wdt_probe(struct platform_device *pdev)
 
 	wdev->ext_reset = of_property_read_bool(dev->of_node,
 						"fsl,ext-reset-output");
+	wdev->test_enabled = of_property_read_bool(pdev->dev.of_node,
+						"unipi,test-enabled");
 	/*
 	 * The i.MX7D doesn't support low power mode, so we need to ping the watchdog
 	 * during suspend.
-- 
2.30.2

